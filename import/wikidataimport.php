<?php
// Import all existing Wikidata items to local table
require("../www/connect.inc.php");

$insertdb = $dbh->prepare('
    INSERT INTO osmetymology.wikidata (itemid, name, description, labels, descriptions, claims, sitelinks, aliases)
    VALUES (?,?,?,?,?,?,?,?)
');

function getBestLabel($labels)
{ // Run through languages and search for existing value; pick first existing
    $languages = ['da', 'en', 'mul', 'sv', 'nb', 'de', 'es', 'fr', 'fi', 'is'];
    $label = NULL;
    foreach ($languages as $language) {
        if (isset($labels->$language)) {
            $label = $labels->$language->value;
            break;
        }
    }
    return $label;
}

function createTables() {
    global $dbh, $insertdb;
    $dbh->query('DROP TABLE IF EXISTS osmetymology.wikidata');
    $dbh->query('
        CREATE TABLE osmetymology.wikidata (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            itemId TEXT,
            name TEXT COLLATE "da_DK",
            description TEXT COLLATE "da_DK",
            labels JSONB,
            descriptions JSONB,
            claims JSONB,
            sitelinks JSONB,
            aliases JSONB
        )
    ');
    
    $dbh->query('CREATE UNIQUE INDEX wikidata_itemid_idx ON osmetymology.wikidata ("itemid")');
    $dbh->query('CREATE INDEX wikidata_name_idx ON osmetymology.wikidata ("name")');    

    $dbh->query('DROP TABLE IF EXISTS osmetymology.wikilabels');
    $dbh->query('
        CREATE TABLE osmetymology.wikilabels (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            itemId TEXT,
            label TEXT COLLATE "da_DK",
            searchlabel TEXT COLLATE "da_DK"
        )
    ');
    $dbh->query('CREATE INDEX wikilabels_label_idx ON osmetymology.wikilabels ("label" text_pattern_ops)');
    $dbh->query('CREATE INDEX wikilabels_searchlabel_idx ON osmetymology.wikilabels ("searchlabel" text_pattern_ops)');
    return TRUE;
}

function getItemIds() {
    global $dbh;
    $itemIds = $dbh->query(
        <<<EOD
        WITH split_content AS (
            SELECT trim(both ' ' FROM unnest(string_to_array("name:etymology:wikidata", ';'))) AS single_items
            FROM osmetymology.locations_agg
        )
        SELECT DISTINCT single_items FROM split_content WHERE single_items ~ '^Q\d+$'
        EOD,
        PDO::FETCH_COLUMN,
        0
    )->fetchAll();
    return $itemIds;
}

function getInstanceOfItems()
{
    global $dbh;
    $instanceofItems = $dbh->query(
        <<<EOD
        SELECT DISTINCT claims#>'{P31,0}'->'mainsnak'->'datavalue'->'value'->>'id' AS instanceOfItemId
        FROM osmetymology.wikidata w
        WHERE claims#>'{P31,0}'->'mainsnak'->'datavalue'->'value'->>'id' IS NOT NULL
        AND claims#>'{P31,0}'->'mainsnak'->'datavalue'->'value'->>'id' NOT IN (SELECT itemid FROM osmetymology.wikidata)
        EOD,
        PDO::FETCH_COLUMN,
        0
    )->fetchAll();
    return $instanceofItems;
}

function importItemIds($itemIds)
{
    global $insertdb, $dbh;
    $itemsInserted = 0;
    $itemLimit = 50;
    $apiurlprefix = 'https://www.wikidata.org/w/api.php?action=wbgetentities&format=json&ids=';

    // Validate item IDs
    foreach ($itemIds as $itemId) {
        if (!is_string($itemId) || !preg_match('/^Q\d+$/', $itemId)) {
            die("Invalid item ID: $itemId. All items must be strings in the format Q followed by numbers." . PHP_EOL);
        }
    }

    // Delete existing entries for the specified item IDs
    $dbh->query("DELETE FROM osmetymology.wikidata WHERE itemId IN ('" . implode("','", $itemIds) . "')");

    $chunks = array_chunk($itemIds, $itemLimit);

    print "Importing " . count($itemIds) . " items in " . count($chunks) . " chunks:" . PHP_EOL;
    foreach ($chunks as $chunkid => $chunk) {
        print "Chunk " . ($chunkid + 1) . " of " . (count($chunks)) . "\r";
        $itemList = implode('|', $chunk);
        $url = $apiurlprefix . $itemList;
        $jsonResult = json_decode(file_get_contents($url)); // TODO: Error handling
        if (isset($jsonResult->entities)) {
            foreach ($jsonResult->entities as $entity) {
                $pageid = $entity->id;
                if (isset($entity->redirects->from)) {
                    $pageid = $entity->redirects->from; // for the time, preserve redirects as their own topic to avoid duplicates
                }
                $name = getBestLabel($entity->labels);
                $description = getBestLabel($entity->descriptions);
                $labels = json_encode($entity->labels);
                $descriptions = json_encode($entity->descriptions);
                $claims = json_encode($entity->claims);
                $sitelinks = json_encode($entity->sitelinks);
                $aliases = json_encode($entity->aliases);
                $insertdb->execute([$pageid, $name, $description, $labels, $descriptions, $claims, $sitelinks, $aliases]);
                $itemsInserted++;
            }
        }
    }
    print PHP_EOL;
    print "Inserted " . $itemsInserted . " items." . PHP_EOL;
    return true;
}

function insertLabels() {
    global $dbh;
    $dbh->query('TRUNCATE osmetymology.wikilabels'); // Truncate table before inserting
    $dbh->query(
        <<<EOD
        INSERT INTO osmetymology.wikilabels (itemId, label, searchlabel)
        (
        SELECT itemid, name AS label, osmetymology.toSearchString(name) as searchlabel 
        FROM osmetymology.wikidata
        UNION
        SELECT itemid, value->>'value' AS label, osmetymology.toSearchString(value->>'value') as searchlabel
        FROM osmetymology.wikidata, jsonb_array_elements(aliases->'da')
        )
        EOD);
}

function handleCleanImport() {
    createTables();
    $itemIds = getItemIds();
    print date("H:i:s") . ": Initial import" . PHP_EOL;
    importItemIds($itemIds);
    print date("H:i:s") . ": Fetching 'Instance of' items" . PHP_EOL;
    $instanceofItems = getInstanceOfItems();
    print date("H:i:s") . ": Instance import" . PHP_EOL;
    importItemIds($instanceofItems);
    print date("H:i:s") . ": Insert labels" . PHP_EOL;
    insertLabels();
    print date("H:i:s") . ": Wikiimport done!" . PHP_EOL;
}

function handlePropertyItems($property) {
    global $dbh;
    $query = "
    WITH items AS (
        SELECT DISTINCT jsonb_array_elements(claims->'$property')->'mainsnak'->'datavalue'->'value'->>'id' AS id FROM osmetymology.wikidata
    )
    SELECT id FROM items WHERE id IS NOT NULL
    ";
    $itemIds = $dbh->query($query, PDO::FETCH_COLUMN, 0)->fetchAll();

    if (!empty($itemIds)) {
        importItemIds($itemIds);
        insertLabels();
    } else {
        print "No items found for property $property." . PHP_EOL;
    }
}

function handleAddItems($items) {
    $itemIds = explode(',', $items);
    foreach ($itemIds as $itemId) {
        if (!preg_match('/^Q\d+$/', $itemId)) {
            die("Invalid item ID: $itemId. All items must be in the format Q followed by numbers." . PHP_EOL);
        }
    }
    importItemIds($itemIds);
    insertLabels();
}

$options = getopt("", ["cleanimport", "propertyitems:", "additems:"]);

if (isset($options['cleanimport'])) {
    handleCleanImport();
} elseif (isset($options['propertyitems'])) {
    $property = $options['propertyitems'];
    if (!preg_match('/^P\d+$/', $property)) {
        die("Invalid property ID: $property. It must start with P followed by numbers." . PHP_EOL);
    }
    handlePropertyItems($property);
} elseif (isset($options['additems'])) {
    $items = $options['additems'];
    if (empty($items)) {
        die("No items provided for additems option." . PHP_EOL);
    }
    handleAddItems($items);
} else {
    print "Usage: php wikidataimport.php [--cleanimport] [--propertyitems=P12345] [--additems=Q12,Q1234]" . PHP_EOL;
}
