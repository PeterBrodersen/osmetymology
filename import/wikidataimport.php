<?php
// Import all existing Wikidata items to local table
require("../www/connect.inc.php");

// Set User-Agent globally
ini_set('user_agent', 'Findvej OSM Etymology (https://github.com/PeterBrodersen/osmetymology/)');

// Prepare the insert statement for Wikidata items
$insertdb = $dbh->prepare('
    INSERT INTO osmetymology.wikidata (itemid, name, description, labels, descriptions, claims, sitelinks, aliases)
    VALUES (?,?,?,?,?,?,?,?)
');

function getBestLabel($labels)
{ // Run through languages and search for existing value; pick first existing
    $languages = ['da', 'en', 'mul', 'sv', 'nb', 'de', 'es', 'fr', 'fi', 'is'];
    $label = NULL;
    foreach ($languages as $language) {
        if (isset($labels->$language)) {
            $label = $labels->$language->value;
            break;
        }
    }
    return $label;
}

function createTables()
{
    global $dbh, $insertdb;
    $dbh->query('DROP TABLE IF EXISTS osmetymology.wikidata');
    $dbh->query('
        CREATE TABLE osmetymology.wikidata (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            itemId TEXT,
            name TEXT COLLATE "da_DK",
            description TEXT COLLATE "da_DK",
            labels JSONB,
            descriptions JSONB,
            claims JSONB,
            sitelinks JSONB,
            aliases JSONB
        )
    ');

    $dbh->query('CREATE UNIQUE INDEX wikidata_itemid_idx ON osmetymology.wikidata ("itemid")');
    $dbh->query('CREATE INDEX wikidata_name_idx ON osmetymology.wikidata ("name")');

    $dbh->query('DROP TABLE IF EXISTS osmetymology.wikilabels');
    $dbh->query('
        CREATE TABLE osmetymology.wikilabels (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            itemId TEXT,
            label TEXT COLLATE "da_DK",
            searchlabel TEXT COLLATE "da_DK"
        )
    ');
    $dbh->query('CREATE INDEX wikilabels_label_idx ON osmetymology.wikilabels ("label" text_pattern_ops)');
    $dbh->query('CREATE INDEX wikilabels_searchlabel_idx ON osmetymology.wikilabels ("searchlabel" text_pattern_ops)');
    return TRUE;
}

function getItemIds()
{
    global $dbh;
    $itemIds = $dbh->query(
        <<<EOD
        WITH split_content AS (
            SELECT trim(both ' ' FROM unnest(string_to_array("name:etymology:wikidata", ';'))) AS single_items
            FROM osmetymology.locations_agg
        )
        SELECT DISTINCT single_items FROM split_content WHERE single_items ~ '^Q\d+$'
        EOD,
        PDO::FETCH_COLUMN,
        0
    )->fetchAll();
    return $itemIds;
}

function getMissingItemIds()
{
    global $dbh;
    $tableExists = $dbh->query("
        SELECT to_regclass('osmetymology.wikidata') IS NOT NULL AS exists
    ")->fetch(PDO::FETCH_ASSOC);
    if (!$tableExists || !$tableExists['exists']) {
        die("Error: Table osmetymology.wikidata does not exist." . PHP_EOL);
    }
    $itemIds = $dbh->query(
        <<<EOD
        WITH split_content AS (
            SELECT trim(both ' ' FROM unnest(string_to_array("name:etymology:wikidata", ';'))) AS single_items
            FROM osmetymology.locations_agg
        )
        SELECT DISTINCT single_items FROM split_content
        LEFT JOIN osmetymology.wikidata ON single_items = wikidata.itemid
        WHERE single_items ~ '^Q\d+$'
        AND wikidata.itemid IS NULL
        EOD,
        PDO::FETCH_COLUMN,
        0
    )->fetchAll();
    return $itemIds;
}

function getInstanceOfItems()
{
    global $dbh;
    $instanceofItems = $dbh->query(
        <<<EOD
        SELECT DISTINCT claims->'P31'->0->'mainsnak'->'datavalue'->'value'->>'id' AS instanceOfItemId
        FROM osmetymology.wikidata w
        WHERE claims->'P31'->0->'mainsnak'->'datavalue'->'value'->>'id' IS NOT NULL
        AND claims->'P31'->0->'mainsnak'->'datavalue'->'value'->>'id' NOT IN (SELECT itemid FROM osmetymology.wikidata)
        EOD,
        PDO::FETCH_COLUMN,
        0
    )->fetchAll();
    return $instanceofItems;
}

function importItemIds($itemIds)
{
    global $insertdb, $dbh;
    $itemsInserted = 0;
    $itemLimit = 50;
    $apiurlprefix = 'https://www.wikidata.org/w/api.php?action=wbgetentities&format=json&ids=';

    // Validate item IDs
    foreach ($itemIds as $itemId) {
        if (!is_string($itemId) || !preg_match('/^Q\d+$/', $itemId)) {
            die("Invalid item ID: $itemId. All items must be strings in the format Q followed by numbers." . PHP_EOL);
        }
    }

    // Delete existing entries for the specified item IDs
    $dbh->query("DELETE FROM osmetymology.wikidata WHERE itemId IN ('" . implode("','", $itemIds) . "')");

    $chunks = array_chunk($itemIds, $itemLimit);

    print "Importing " . count($itemIds) . " items in " . count($chunks) . " chunks:" . PHP_EOL;
    foreach ($chunks as $chunkid => $chunk) {
        print "Chunk " . ($chunkid + 1) . " of " . (count($chunks)) . "\r";
        $itemList = implode('|', $chunk);
        $url = $apiurlprefix . $itemList;

        $maxAttempts = 3;
        $attempt = 0;
        do {
            $json = @file_get_contents($url);
            $httpCode = 200;
            if (isset($http_response_header) && is_array($http_response_header)) {
                foreach ($http_response_header as $header) {
                    if (preg_match('#^HTTP/\d+\.\d+\s+(\d+)#', $header, $matches)) {
                        $httpCode = (int)$matches[1];
                        break;
                    }
                }
            }
            if ($json === false || $httpCode >= 400) {
                // Error: wait and retry
                $attempt++;
                if ($attempt < $maxAttempts) {
                    sleep(5);
                } else {
                    print "\nError fetching $url (HTTP $httpCode). Skipping after $maxAttempts attempts.\n";
                    break;
                }
            }
        } while (($json === false || $httpCode >= 400) && $attempt < $maxAttempts);
        $jsonResult = json_decode($json);
        if (isset($jsonResult->entities)) {
            foreach ($jsonResult->entities as $entity) {
                $pageid = $entity->id;
                if (isset($entity->redirects->from)) {
                    $pageid = $entity->redirects->from; // for the time, preserve redirects as their own topic to avoid duplicates
                }
                $name = getBestLabel($entity->labels);
                $description = getBestLabel($entity->descriptions);
                $labels = json_encode($entity->labels);
                $descriptions = json_encode($entity->descriptions);
                $claims = json_encode($entity->claims);
                $sitelinks = json_encode($entity->sitelinks);
                $aliases = json_encode($entity->aliases);
                $insertdb->execute([$pageid, $name, $description, $labels, $descriptions, $claims, $sitelinks, $aliases]);
                $itemsInserted++;
            }
        }
    }
    print PHP_EOL;
    print "Inserted " . $itemsInserted . " items." . PHP_EOL;
    return true;
}

function createGINIndex()
{
    global $dbh;
    $dbh->query('CREATE INDEX wikidata_claims_gin_idx ON osmetymology.wikidata USING gin(claims)');
    return true;
}

function insertLabels()
{
    global $dbh;
    $dbh->query('TRUNCATE osmetymology.wikilabels'); // Truncate table before inserting
    $dbh->query(
        <<<EOD
        INSERT INTO osmetymology.wikilabels (itemId, label, searchlabel)
        (
        SELECT itemid, name AS label, osmetymology.toSearchString(name) as searchlabel 
        FROM osmetymology.wikidata
        UNION
        SELECT itemid, value->>'value' AS label, osmetymology.toSearchString(value->>'value') as searchlabel
        FROM osmetymology.wikidata, jsonb_array_elements(aliases->'da')
        )
        EOD
    );
}

function handleAutoImport()
{
    global $dbh;
    $tableExists = $dbh->query("
        SELECT to_regclass('osmetymology.wikidata') IS NOT NULL AS exists
    ")->fetch(PDO::FETCH_ASSOC);
    if (!$tableExists || !$tableExists['exists']) {
        handleCleanImport();
    } else {
        handleMissingItems();
    }
}

function handleCleanImport()
{
    createTables();
    $itemIds = getItemIds();
    print date("H:i:s") . ": Initial import" . PHP_EOL;
    importItemIds($itemIds);
    print date("H:i:s") . ": Fetching 'Instance of' items" . PHP_EOL;
    $instanceofItems = getInstanceOfItems();
    print date("H:i:s") . ": Instance import" . PHP_EOL;
    importItemIds($instanceofItems);
    print date("H:i:s") . ": Creating GIN index" . PHP_EOL;
    createGINIndex();
    print date("H:i:s") . ": Insert labels" . PHP_EOL;
    insertLabels();
    print date("H:i:s") . ": Wikiimport done!" . PHP_EOL;
}

function handleMissingItems()
{
    $itemIds = getMissingItemIds();
    print date("H:i:s") . ": Import missing items" . PHP_EOL;
    importItemIds($itemIds);
    insertLabels();
}

function handlePropertyItems($property)
{
    global $dbh;
    $query = "
    WITH items AS (
        SELECT DISTINCT jsonb_array_elements(claims->'$property')->'mainsnak'->'datavalue'->'value'->>'id' AS id FROM osmetymology.wikidata
    )
    SELECT id FROM items WHERE id IS NOT NULL
    ";
    $itemIds = $dbh->query($query, PDO::FETCH_COLUMN, 0)->fetchAll();

    if (!empty($itemIds)) {
        importItemIds($itemIds);
        insertLabels();
    } else {
        print "No items found for property $property." . PHP_EOL;
    }
}

function handleAddItems($items)
{
    $itemIds = explode(',', $items);
    foreach ($itemIds as $itemId) {
        if (!preg_match('/^Q\d+$/', $itemId)) {
            die("Invalid item ID: $itemId. All items must be in the format Q followed by numbers." . PHP_EOL);
        }
    }
    importItemIds($itemIds);
    insertLabels();
}

$options = getopt("", ["auto", "cleanimport", "missingitems", "propertyitems:", "additems:"]);

if (isset($options['auto'])) { // Clean import if no table, else missing items
    handleAutoImport();
} elseif (isset($options['cleanimport'])) {
    handleCleanImport();
} elseif (isset($options['missingitems'])) {
    handleMissingItems();
} elseif (isset($options['propertyitems'])) {
    $property = $options['propertyitems'];
    if (!preg_match('/^P\d+$/', $property)) {
        die("Invalid property ID: $property. It must start with P followed by numbers." . PHP_EOL);
    }
    handlePropertyItems($property);
} elseif (isset($options['additems'])) {
    $items = $options['additems'];
    if (empty($items)) {
        die("No items provided for additems option." . PHP_EOL);
    }
    handleAddItems($items);
} else {
    print "Usage: php wikidataimport.php [--auto] [--cleanimport] [--missingitems] [--propertyitems=P12345] [--additems=Q12,Q1234]" . PHP_EOL;
}
