-- Create normalized search string for all uses
CREATE OR REPLACE FUNCTION osmetymology.toSearchString (text text) RETURNS text
	AS $$
		SELECT TRANSLATE(REGEXP_REPLACE(LOWER(text), '[^[:alnum:]]', '', 'gi'), 'áàâäãçéèêëíìîïñóòôöõúùûüýÿ', 'aaaaaceeeeiiiinooooouuuuyy')
	$$
	LANGUAGE SQL
	IMMUTABLE
	RETURNS NULL ON NULL INPUT;

-- Normalize featuretype from tags
CREATE OR REPLACE FUNCTION osmetymology.featureType (tags jsonb) RETURNS text
AS $$
	SELECT CASE
		WHEN tags->>'leisure' = 'park' THEN 'park'
		WHEN tags->>'tourism' = 'artwork' THEN 'artwork'
		WHEN tags->>'amenity' = 'place_of_worship' THEN 'place_of_worship'
		WHEN tags->>'office' is not null THEN 'office'
		WHEN tags->>'place' = 'square' THEN 'square'
		WHEN tags->>'place' in ('city','borough','suburb','quarter','neighbourhood','city_block','town','village','hamlet','islet') THEN 'place'
		WHEN tags->>'tourism' = 'museum' THEN 'museum'
		WHEN tags->>'highway' IS NOT NULL OR tags->'footway' IS NOT NULL OR tags->'cycleway' IS NOT NULL THEN 'way'
		WHEN tags->>'amenity' = 'parking' THEN 'parking'
		WHEN tags->>'sport' = 'equestrian' THEN 'equestrian'
		WHEN tags->>'amenity' = 'school' THEN 'school'
		WHEN tags->>'man_made' = 'bridge' THEN 'bridge'
		WHEN tags->>'natural' = 'tree' OR tags->>'natural' = 'wood' OR tags->>'landuse' = 'forest' THEN 'wood'
		WHEN tags->>'leisure' = 'sports_centre' THEN 'sport'
		WHEN tags->>'power' = 'substation' THEN 'power'
		WHEN tags->>'historic' = 'castle' THEN 'castle'
		WHEN tags->>'building' is not NULL THEN 'building'
		ELSE ''
	END
	AS featuretype
$$
LANGUAGE SQL
IMMUTABLE
RETURNS NULL ON NULL INPUT;

-- Helper function for grouping and merging json together
CREATE OR REPLACE FUNCTION jsonb_merge(a jsonb, b jsonb)
RETURNS jsonb LANGUAGE sql IMMUTABLE AS $$
    SELECT a || b;
$$;

CREATE OR REPLACE AGGREGATE jsonb_merge_agg(jsonb) (
    SFUNC = jsonb_merge,
    STYPE = jsonb,
    INITCOND = '{}'
);

-- Create gender helper table; normalize cisgender and transgender
DROP TABLE IF EXISTS osmetymology.gendermap;
CREATE TABLE osmetymology.gendermap (
	id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	itemId TEXT,
	gender TEXT
);

INSERT INTO osmetymology.gendermap (itemId, gender)
VALUES ('Q6581072','female'), ('Q6581097','male'), ('Q1052281', 'female'), ('Q2449503', 'male');

-- Create aggregated table
DROP TABLE IF EXISTS osmetymology.ways_agg;
CREATE TABLE osmetymology.ways_agg (
	id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	name TEXT COLLATE "da_DK",
	searchname TEXT COLLATE "da_DK",
	geomtype TEXT COLLATE "da_DK",
	featuretype TEXT COLLATE "da_DK",
	municipality_code varchar,
	object_ids BIGINT[],
	"name:etymology" TEXT COLLATE "da_DK",
	"name:etymology:wikipedia" TEXT COLLATE "da_DK",
	"name:etymology:wikidata" TEXT COLLATE "da_DK",
	wikidatas TEXT[] COLLATE "da_DK",
	geom GEOMETRY(Geometry, 4326),
	geom_dk GEOMETRY(Geometry, 25832)
);

-- Import points, ways, areas/polygons; intersect on municipality boundaries
-- Do we need to use ST_Intersection() for points as they should only belong to one municipality? There could be several points grouped together though
-- Several points should probably still be aggregated together (e.g. two bus stops across each other with the same name)
INSERT INTO osmetymology.ways_agg (name, searchname, geomtype, featuretype, municipality_code, object_ids, "name:etymology", "name:etymology:wikipedia", "name:etymology:wikidata", wikidatas, geom)
(
	SELECT name, osmetymology.toSearchString(name), 'point', osmetymology.featureType(jsonb_merge_agg(tags)), m.kode, array_agg(node_id), "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", regexp_split_to_array("name:etymology:wikidata", '\s*;\s*'), ST_Intersection(ST_Transform(ST_Collect(geom), 4326), m.wkb_geometry)
	FROM osmetymology.osm_points op
	INNER JOIN osmetymology.municipalities m ON ST_Transform(op.geom,4326) && m.wkb_geometry AND ST_Intersects(ST_Transform(op.geom,4326), m.wkb_geometry)
	WHERE name IS NOT NULL AND ("name:etymology" IS NOT NULL OR "name:etymology:wikipedia" IS NOT NULL OR "name:etymology:wikidata" is not NULL)
	GROUP by name, m.navn, m.kode, "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", m.wkb_geometry
)
UNION
(
	SELECT name, osmetymology.toSearchString(name), 'line', osmetymology.featureType(jsonb_merge_agg(tags)), m.kode, array_agg(way_id), "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", regexp_split_to_array("name:etymology:wikidata", '\s*;\s*'), ST_Intersection(ST_Transform(ST_Collect(geom), 4326), m.wkb_geometry)
	FROM osmetymology.osm_ways ow
	INNER JOIN osmetymology.municipalities m ON ST_Transform(ow.geom,4326) && m.wkb_geometry AND ST_Intersects(ST_Transform(ow.geom,4326), m.wkb_geometry)
	WHERE name IS NOT NULL AND ("name:etymology" IS NOT NULL OR "name:etymology:wikipedia" IS NOT NULL OR "name:etymology:wikidata" is not NULL)
	GROUP by name, m.navn, m.kode, "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", m.wkb_geometry
)
UNION (
	SELECT name, osmetymology.toSearchString(name), 'polygon', osmetymology.featureType(jsonb_merge_agg(tags)), m.kode, array_agg(area_id), "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", regexp_split_to_array("name:etymology:wikidata", '\s*;\s*'), ST_Intersection(ST_Transform(ST_Union(geom), 4326), m.wkb_geometry)
	FROM osmetymology.osm_polygons op
	INNER JOIN osmetymology.municipalities m ON ST_Transform(op.geom,4326) && m.wkb_geometry AND ST_Intersects(ST_Transform(op.geom,4326), m.wkb_geometry)
	WHERE name IS NOT NULL AND ("name:etymology" IS NOT NULL OR "name:etymology:wikipedia" IS NOT NULL OR "name:etymology:wikidata" is not NULL)
	GROUP by name, m.navn, m.kode, "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", m.wkb_geometry
);

UPDATE osmetymology.ways_agg SET geom_dk = ST_Transform(geom, 25832);

CREATE INDEX ways_agg_geom_idx ON osmetymology.ways_agg USING gist (geom);
CREATE INDEX ways_agg_geom_dk_idx ON osmetymology.ways_agg USING gist (geom_dk);
CREATE INDEX ways_agg_name_idx ON osmetymology.ways_agg ("name" text_pattern_ops);
CREATE INDEX ways_agg_searchname_idx ON osmetymology.ways_agg ("searchname" text_pattern_ops);
CREATE INDEX ways_agg_municipality_idx ON osmetymology.ways_agg ("municipality_code");
CREATE INDEX ways_agg_name_etymology_wikidata_idx ON osmetymology.ways_agg ("name:etymology:wikidata");
CREATE INDEX ways_agg_wikidatas_idx ON osmetymology.ways_agg USING gin("wikidatas");

DROP INDEX IF EXISTS osmetymology.municipalities_kode_idx;
CREATE INDEX municipalities_kode_idx ON osmetymology.municipalities ("kode");

-- Create stats table
DROP TABLE IF EXISTS osmetymology.stats;
CREATE TABLE osmetymology.stats (
	id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	label TEXT COLLATE "da_DK",
	value INT
);
