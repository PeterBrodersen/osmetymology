-- Create normalized search string for all uses
CREATE OR REPLACE FUNCTION osmetymology.toSearchString (text text) RETURNS text
	AS $$
		SELECT TRANSLATE(REGEXP_REPLACE(LOWER(text), '[^[:alnum:]]', '', 'gi'), 'áàâäãçéèêëíìîïñóòôöõúùûüýÿ', 'aaaaaceeeeiiiinooooouuuuyy')
	$$
	LANGUAGE SQL
	IMMUTABLE
	RETURNS NULL ON NULL INPUT;

-- Normalize featuretype from tags
CREATE OR REPLACE FUNCTION osmetymology.featureType (tags jsonb) RETURNS text
AS $$
	SELECT CASE
		WHEN tags->>'leisure' = 'park' THEN 'park'
		WHEN tags->>'tourism' = 'artwork' THEN 'artwork'
		WHEN tags->>'landuse' = 'cemetery' OR tags->>'amenity' = 'grave_yard' THEN 'cemetery'
		WHEN tags->>'amenity' = 'place_of_worship' THEN 'place_of_worship'
		WHEN tags->>'amenity' = 'prison' THEN 'prison'
		WHEN tags->>'office' IS NOT NULL THEN 'office'
		WHEN tags->>'place' = 'square' THEN 'square'
		WHEN tags->>'place' IN ('city','borough','suburb','quarter','neighbourhood','city_block','town','village','hamlet','islet') THEN 'place'
		WHEN tags->>'tourism' = 'museum' THEN 'museum'
		WHEN tags->>'highway' IS NOT NULL OR tags->>'footway' IS NOT NULL OR tags->>'cycleway' IS NOT NULL THEN 'way'
		WHEN tags->>'amenity' = 'parking' THEN 'parking'
		WHEN tags->>'sport' = 'equestrian' THEN 'equestrian'
		WHEN tags->>'amenity' IN ('school','college') THEN 'school'
		WHEN tags->>'amenity' = 'university' THEN 'university'
		WHEN tags->>'amenity' IN ('bar','pub','biergarten','nightclub','cafe') THEN 'alcohol'
		WHEN tags->>'man_made' = 'bridge' THEN 'bridge'
		WHEN tags->>'aeroway' IS NOT NULL THEN 'aeroway'
		WHEN tags->>'tourism' = 'zoo' THEN 'zoo'
		WHEN tags->>'amenity' = 'hospital' THEN 'hospital'
		WHEN tags->>'amenity' = 'kindergarten' THEN 'kindergarten'
		WHEN tags->>'power' IS NOT NULL THEN 'power'
		WHEN tags->>'tourism' = 'theme_park' THEN 'theme_park'
		WHEN tags->>'shop' = 'bakery' THEN 'bakery'
		WHEN tags->>'shop' IS NOT NULL THEN 'shop'
		WHEN tags->>'natural' = 'tree' OR tags->>'natural' = 'wood' OR tags->>'landuse' = 'forest' OR tags->>'leisure' = 'garden' THEN 'wood'
		WHEN tags->>'leisure' = 'sports_centre' THEN 'sport'
		WHEN tags->>'leisure' = 'playground' THEN 'playground'
		WHEN tags->>'amenity' = 'theatre' THEN 'theatre'
		WHEN tags->>'amenity' = 'cinema' THEN 'cinema'
		WHEN tags->>'amenity' = 'library' THEN 'library'
		WHEN tags->>'power' = 'substation' THEN 'power'
		WHEN tags->>'historic' = 'castle' THEN 'castle'
		WHEN tags->>'harbour' IS NOT NULL OR tags->>'water' = 'harbour' THEN 'harbour'
		WHEN tags->>'natural' IN ('water','bay') THEN 'water'
		WHEN tags->>'building' IS NOT NULL OR tags->>'building:part' IS NOT NULL THEN 'building'
		ELSE ''
	END
	AS featuretype
$$
LANGUAGE SQL
IMMUTABLE
RETURNS NULL ON NULL INPUT;

-- Helper function for grouping and merging json together
CREATE OR REPLACE FUNCTION jsonb_merge(a jsonb, b jsonb)
RETURNS jsonb LANGUAGE sql IMMUTABLE AS $$
    SELECT a || b;
$$;

CREATE OR REPLACE AGGREGATE jsonb_merge_agg(jsonb) (
    SFUNC = jsonb_merge,
    STYPE = jsonb,
    INITCOND = '{}'
);

-- Create gender helper table; normalize cisgender and transgender
DROP TABLE IF EXISTS osmetymology.gendermap;
CREATE TABLE osmetymology.gendermap (
	id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	itemId TEXT,
	gender TEXT
);

INSERT INTO osmetymology.gendermap (itemId, gender)
VALUES ('Q6581072','female'), ('Q6581097','male'), ('Q1052281', 'female'), ('Q2449503', 'male'), ('Q15145779', 'female'), ('Q15145778', 'male');

-- Create aggregated table
DROP TABLE IF EXISTS osmetymology.locations_agg;
CREATE TABLE osmetymology.locations_agg (
	id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	name TEXT COLLATE "da_DK",
	searchname TEXT COLLATE "da_DK",
	geomtype TEXT COLLATE "da_DK",
	featuretype TEXT COLLATE "da_DK",
	municipality_code varchar,
	object_ids BIGINT[],
	"name:etymology" TEXT COLLATE "da_DK",
	"name:etymology:wikipedia" TEXT COLLATE "da_DK",
	"name:etymology:wikidata" TEXT COLLATE "da_DK",
	wikidatas TEXT[] COLLATE "da_DK",
	geom GEOMETRY(Geometry, 4326),
	geom_dk GEOMETRY(Geometry, 25832)
);

-- Import points, ways, areas/polygons; intersect on municipality boundaries
-- Do we need to use ST_Intersection() for points as they should only belong to one municipality? There could be several points grouped together though
-- Several points should probably still be aggregated together (e.g. two bus stops across each other with the same name)
INSERT INTO osmetymology.locations_agg (name, searchname, geomtype, featuretype, municipality_code, object_ids, "name:etymology", "name:etymology:wikipedia", "name:etymology:wikidata", wikidatas, geom)
(
	SELECT name, osmetymology.toSearchString(name), 'point', osmetymology.featureType(jsonb_merge_agg(tags)), m.kode, array_agg(node_id), "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", regexp_split_to_array("name:etymology:wikidata", '\s*;\s*'), ST_Intersection(ST_Transform(ST_Collect(geom), 4326), m.wkb_geometry)
	FROM osmetymology.osm_points op
	INNER JOIN osmetymology.municipalities m ON ST_Transform(op.geom,4326) && m.wkb_geometry AND ST_Intersects(ST_Transform(op.geom,4326), m.wkb_geometry)
	WHERE name IS NOT NULL AND ("name:etymology" IS NOT NULL OR "name:etymology:wikipedia" IS NOT NULL OR "name:etymology:wikidata" is not NULL)
	GROUP by name, m.navn, m.kode, "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", m.wkb_geometry
)
UNION
(
	SELECT name, osmetymology.toSearchString(name), 'line', osmetymology.featureType(jsonb_merge_agg(tags)), m.kode, array_agg(way_id), "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", regexp_split_to_array("name:etymology:wikidata", '\s*;\s*'), ST_Intersection(ST_Transform(ST_Collect(geom), 4326), m.wkb_geometry)
	FROM osmetymology.osm_ways ow
	INNER JOIN osmetymology.municipalities m ON ST_Transform(ow.geom,4326) && m.wkb_geometry AND ST_Intersects(ST_Transform(ow.geom,4326), m.wkb_geometry)
	WHERE name IS NOT NULL AND ("name:etymology" IS NOT NULL OR "name:etymology:wikipedia" IS NOT NULL OR "name:etymology:wikidata" is not NULL)
	GROUP by name, m.navn, m.kode, "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", m.wkb_geometry
)
UNION (
	SELECT name, osmetymology.toSearchString(name), 'polygon', osmetymology.featureType(jsonb_merge_agg(tags)), m.kode, array_agg(area_id), "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", regexp_split_to_array("name:etymology:wikidata", '\s*;\s*'), ST_Intersection(ST_Transform(ST_Union(geom), 4326), m.wkb_geometry)
	FROM osmetymology.osm_polygons op
	INNER JOIN osmetymology.municipalities m ON ST_Transform(op.geom,4326) && m.wkb_geometry AND ST_Intersects(ST_Transform(op.geom,4326), m.wkb_geometry)
	WHERE name IS NOT NULL AND ("name:etymology" IS NOT NULL OR "name:etymology:wikipedia" IS NOT NULL OR "name:etymology:wikidata" is not NULL)
	GROUP by name, m.navn, m.kode, "name:etymology", "name:etymology:wikipedia","name:etymology:wikidata", m.wkb_geometry
);

UPDATE osmetymology.locations_agg SET geom_dk = ST_Transform(geom, 25832);

CREATE INDEX locations_agg_geom_idx ON osmetymology.locations_agg USING gist (geom);
CREATE INDEX locations_agg_geom_dk_idx ON osmetymology.locations_agg USING gist (geom_dk);
CREATE INDEX locations_agg_name_idx ON osmetymology.locations_agg ("name" text_pattern_ops);
CREATE INDEX locations_agg_searchname_idx ON osmetymology.locations_agg ("searchname" text_pattern_ops);
CREATE INDEX locations_agg_municipality_idx ON osmetymology.locations_agg ("municipality_code");
CREATE INDEX locations_agg_name_etymology_wikidata_idx ON osmetymology.locations_agg ("name:etymology:wikidata");
CREATE INDEX locations_agg_wikidatas_idx ON osmetymology.locations_agg USING gin("wikidatas");

DROP INDEX IF EXISTS osmetymology.municipalities_kode_idx;
CREATE INDEX municipalities_kode_idx ON osmetymology.municipalities ("kode");

-- Create map from locations to Wikidata items
DROP TABLE IF EXISTS osmetymology.wikidatamap;
CREATE TABLE osmetymology.wikidatamap AS
SELECT
	id AS location_id,
	unnest(wikidatas) AS wikidata_id
FROM
	osmetymology.locations_agg
WHERE
	wikidatas IS NOT NULL AND array_length(wikidatas, 1) > 0;

CREATE INDEX wikidatamap_wikidata_id_idx ON osmetymology.wikidatamap (wikidata_id);
CREATE INDEX wikidatamap_location_id_idx ON osmetymology.wikidatamap (location_id);
